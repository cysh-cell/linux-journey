document.addEventListener('DOMContentLoaded', () => {
    const introLessons = [
        {
            id: 1,
            title: "1. Что такое Linux?",
            content: `
                <h2>Что такое Linux?</h2>
                <p>Привет, новичок! Так ты решил погрузиться в удивительный мир под названием Linux? Впереди тебя ждёт прекрасное и увлекательное путешествие!</p>
                <p>Меня зовут Пингвин Пит, и я буду твоим проводником в этом пути. Давай начнём с небольшой предыстории о том, как появился Linux.</p>
    
                <p>Чтобы понять, откуда взялся Linux, вернёмся к самому началу — к 1969 году, когда Кен Томпсон и Деннис Ритчи из Bell Laboratories разработали операционную систему UNIX. Позже её переписали на языке C, чтобы сделать более переносимой, и со временем она стала широко используемой ОС.</p>
    
                <p>Примерно десятилетие спустя Ричард Столлман начал работать над проектом GNU (GNU — это не UNIX), включавшим ядро под названием Hurd. К сожалению, это ядро так и не было завершено. Однако в рамках этого проекта была создана Стандартная общественная лицензия GNU (GPL) — лицензия свободного программного обеспечения.</p>
    
                <p>Ядро — это самая важная часть операционной системы. Именно оно позволяет «железу» общаться с программным обеспечением. Оно также выполняет множество других задач, но об этом мы поговорим в другом курсе. Пока что просто запомни: ядро управляет практически всем, что происходит в твоей системе.</p>
    
                <p>В то же время появлялись и другие проекты, такие как BSD, MINIX и другие, создававшие UNIX-подобные системы. Однако у всех этих UNIX-подобных систем была одна общая проблема — отсутствие единого, полноценного ядра.</p>
    
                <p>И тогда в 1991 году молодой человек по имени Линус Торвальдс начал разработку того, что сегодня мы знаем как ядро Linux.</p>
            `
        },
        {
            id: 2,
            title: "2. Выбор дистрибутива",
            content: `
                <h2>Выбор дистрибутива</h2>
                <p>В предыдущем уроке мы узнали о ядре Linux, которое ежедневно работает на миллионах устройств по всему миру.</p>
        
                <p>Прежде чем двигаться дальше, стоит уточнить один важный момент: термин «Linux» на самом деле — своего рода неточность. Строго говоря, Linux — это именно <strong>ядро</strong>. Однако большинство операционных систем, использующих это ядро, получили общее название — «Linux-дистрибутивы» или просто «Linux».</p>
        
                <p>Любая Linux-система состоит из трёх основных компонентов:</p>
        
                <ul>
                    <li><strong>Аппаратное обеспечение (Hardware)</strong> — всё «железо», на котором работает система: процессор, память, диски и другие устройства.</li>
                    <li><strong>Ядро Linux (Linux Kernel)</strong> — как мы уже говорили, это ядро операционной системы. Оно управляет оборудованием и определяет, как оно взаимодействует с программным обеспечением.</li>
                    <li><strong>Пользовательское пространство (User Space)</strong> — именно здесь вы, как пользователь, напрямую взаимодействуете с системой: запускаете приложения, работаете с файлами, настраиваете окружение.</li>
                </ul>
        
                <p>Теперь первый шаг, который вам предстоит сделать, — установить Linux на свой компьютер. У вас есть множество вариантов, и этот курс поможет разобраться в них и выбрать подходящий дистрибутив.</p>
        
                <p>Существует огромное количество Linux-дистрибутивов, но мы рассмотрим самые популярные из них.</p>
            `
        }
    ];

    const terminalLessons = [
        {
            id: 1,
            title: "1. Введение в командную строку",
            content: `
                <h2>Введение в командную строку</h2>
                <p>Мир — ваша устрица… или, точнее, оболочка (shell) — ваша устрица.</p>
        
                <p>Что такое оболочка? Оболочка — это программа, которая принимает ваши команды с клавиатуры и передаёт их операционной системе для выполнения. Если вы когда-либо пользовались графическим интерфейсом (GUI), то, скорее всего, видели программы вроде «Терминал» или «Консоль» — это просто приложения, запускающие для вас оболочку.</p>
        
                <p>Во всём этом курсе мы будем изучать удивительные возможности командной оболочки.</p>
        
                <p>Мы будем использовать оболочку <strong>bash</strong> (Bourne Again Shell). Почти все дистрибутивы Linux по умолчанию используют именно bash. Существуют и другие оболочки — например, ksh, zsh, tcsh — но мы не будем их рассматривать.</p>
        
                <p>Давайте начнём! В зависимости от дистрибутива внешний вид приглашения командной строки может отличаться, но в большинстве случаев оно соответствует следующему формату:</p>
        
                <div class="terminal-example">
                    <pre>username@hostname:current_directory<br>pete@icebox:/home/pete $</pre>
                </div>
        
                <p>Обратите внимание на символ <code>$</code> в конце приглашения? У разных оболочек разные приглашения. В нашем случае <code>$</code> означает, что вы работаете под обычным пользователем в оболочках Bash, Bourne или Korn. Когда вы вводите команду, <strong>не нужно</strong> набирать этот символ — он просто показывает, что система готова принимать ввод.</p>
        
                <p>Начнём с простой команды — <code>echo</code>. Эта команда просто выводит указанный текст на экран.</p>
        
                <div class="terminal-example">
                    <pre>$ echo Hello World</pre>
                </div>
            `
        },
        {
            id: 2,
            title: "2. Навигация по файловой системе",
            content: `
                <h2>Навигация по файловой системе</h2>
                <p>В Linux всё является файлом. По мере погружения в мир Linux вы всё глубже поймёте смысл этого утверждения, но пока просто запомните его.</p>
        
                <p>Все файлы организованы в иерархическое дерево каталогов. Самый первый каталог в файловой системе называется <strong>корневым каталогом</strong> (root directory) и обозначается символом <code>/</code>.</p>
        
                <p>В корневом каталоге находятся другие папки и файлы, внутри которых, в свою очередь, могут быть свои подкаталоги и файлы — и так далее. Вот пример структуры такого дерева:</p>
        
                <div class="terminal-example">
                    <pre>/
                        |-- bin
                        |   |-- file1
                        |   |-- file2
                        |-- etc
                        |   |-- file3
                        |   \`-- directory1
                        |       |-- file4
                        |       \`-- file5
                        |-- home
                        |-- var
                    </pre>
                </div>
        
                <p>Расположение файлов и каталогов называется <strong>путём</strong> (path). Например, если у вас есть папка <code>home</code>, внутри неё — папка <code>pete</code>, а внутри неё — папка <code>Movies</code>, то полный путь к ней будет выглядеть так:</p>
        
                <div class="terminal-example">
                    <pre>/home/pete/Movies</pre>
                </div>
        
                <p>Довольно просто, правда?</p>
        
                <p>Навигация по файловой системе, как и в реальной жизни, становится намного проще, если вы знаете, где находитесь и куда направляетесь.</p>
        
                <p>Чтобы узнать, в каком каталоге вы сейчас находитесь, используйте команду <code>pwd</code> (от англ. <em>print working directory</em> — «показать рабочий каталог»). Эта команда выводит полный путь к текущей директории, начиная от корня.</p>
        
                <div class="terminal-example">
                    <pre>$ pwd</pre>
                </div>
        
                <p>Где вы? Где я? Попробуйте выполнить эту команду сами!</p>
            `
        }
    ];

    const textFuContent = [
        {
            id: 1,
            title: 'stdout',
            content: `
                <h2>Перенаправление ввода-вывода (I/O)</h2>
                <p>К настоящему моменту мы уже познакомились со многими командами и их выводом, что подводит нас к следующей теме — потокам ввода-вывода (I/O). Давайте выполним следующую команду и разберем, как она работает.</p>
        
                <div class="terminal-example">
                    <pre>$ echo Hello World > peanuts.txt</pre>
                </div>
        
                <p>Что только что произошло? Проверьте каталог, в котором вы выполнили эту команду, и — о чудо! — вы должны увидеть файл с именем <code>peanuts.txt</code>. Загляните внутрь этого файла, и вы увидите текст <code>Hello World</code>. В одной команде произошло много всего, так что давайте разберём её по частям.</p>
        
                <p>Сначала разберём первую часть:</p>
        
                <div class="terminal-example">
                    <pre>$ echo Hello World</pre>
                </div>
        
                <p>Мы знаем, что эта команда выводит <code>Hello World</code> на экран, но как именно? Процессы используют потоки ввода-вывода для получения входных данных и возврата выходных. По умолчанию команда <code>echo</code> принимает ввод (стандартный ввод или <code>stdin</code>) с клавиатуры и возвращает вывод (стандартный вывод или <code>stdout</code>) на экран. Именно поэтому, когда вы вводите <code>echo Hello World</code> в оболочке, вы видите <code>Hello World</code> на экране. Однако перенаправление ввода-вывода позволяет изменить это поведение по умолчанию, предоставляя нам большую гибкость в работе с файлами.</p>
        
                <p>Перейдём к следующей части команды:</p>
        
                <div class="terminal-example">
                    <pre>></pre>
                </div>
        
                <p>Символ <code>></code> — это оператор перенаправления, который позволяет изменить назначение стандартного вывода. Он позволяет нам направить вывод команды <code>echo Hello World</code> в файл вместо экрана. Если файл ещё не существует, он будет создан. Однако, если файл уже существует, он будет перезаписан (в зависимости от используемой оболочки, вы можете добавить флаг, чтобы предотвратить это).</p>
        
                <p>И это, в общем-то, и есть принцип работы перенаправления стандартного вывода!</p>
        
                <p>Теперь представим, что я не хочу перезаписывать свой <code>peanuts.txt</code>. К счастью, для этого также существует оператор перенаправления — <code>>></code>:</p>
        
                <div class="terminal-example">
                    <pre>$ echo Hello World >> peanuts.txt</pre>
                </div>
        
                <p>Этот оператор <strong>добавит</strong> <code>Hello World</code> в конец файла <code>peanuts.txt</code>. Если файл ещё не существует, он будет создан, так же как при использовании оператора <code>></code>!</p>
            `
        },
        {
            id: 2,
            title: 'stdin',
            content: `
                <h2>Перенаправление стандартного ввода (stdin)</h2>
                <p>В предыдущем уроке мы узнали, что можем использовать различные потоки стандартного вывода, такие как файл или экран. Но существуют также различные потоки стандартного ввода (stdin), которые мы можем использовать. Мы знаем, что можем получать stdin с таких устройств, как клавиатура, но мы также можем использовать файлы, вывод других процессов и терминал. Давайте рассмотрим пример.</p>

                <p>Воспользуемся файлом <code>peanuts.txt</code> из предыдущего урока — помните, в нём был текст <code>Hello World</code>.</p>
        
                <div class="terminal-example">
                    <pre>$ cat < peanuts.txt > banana.txt</pre>
                </div>
        
                <p>Так же, как у нас есть <code>></code> для перенаправления stdout, мы можем использовать <code><</code> для перенаправления stdin.</p>
        
                <p>Обычно в команде <code>cat</code> вы передаёте ей файл, и этот файл становится stdin. В данном случае мы перенаправили <code>peanuts.txt</code> как наш stdin. Затем вывод команды <code>cat peanuts.txt</code> (который будет <code>Hello World</code>) перенаправляется в другой файл с именем <code>banana.txt</code>.</p>
            `
        }
    ];

    const advancedTextFuContent = [
        {
            id: 1,
            title: 'regex',
            content: `
                <h2>Регулярные выражения</h2>
                <p>Регулярные выражения — это мощный инструмент для поиска и выбора текста на основе шаблонов. Они используют специальные обозначения, похожие на уже знакомые нам, например, подстановочный символ <code>*</code>.</p>
        
                <p>Мы рассмотрим несколько самых распространённых конструкций регулярных выражений. Эти правила почти универсальны и работают в большинстве языков программирования.</p>
        
                <p>В качестве тестовой строки будем использовать следующий текст:</p>
        
                <div class="terminal-example">
                    <pre>sally sells seashells<br>by the seashore</pre>
                </div>
        
                <h3>1. Начало строки — <code>^</code></h3>
                <p>Символ <code>^</code> означает «начало строки».</p>
                <div class="terminal-example">
                    <pre>^by</pre>
                </div>
                <p>Этот шаблон найдёт строку <code>by the seashore</code>, потому что она начинается с <code>by</code>.</p>
        
                <h3>2. Конец строки — <code>$</code></h3>
                <p>Символ <code>$</code> означает «конец строки».</p>
                <div class="terminal-example">
                    <pre>seashore$</pre>
                </div>
                <p>Этот шаблон также совпадёт со строкой <code>by the seashore</code>, так как она заканчивается на <code>seashore</code>.</p>
        
                <h3>3. Любой символ — <code>.</code></h3>
                <p>Точка <code>.</code> соответствует любому одному символу.</p>
                <div class="terminal-example">
                    <pre>b.</pre>
                </div>
                <p>Этот шаблон совпадёт с <code>by</code>, потому что <code>b</code> + любой символ = <code>by</code>.</p>
        
                <h3>4. Квадратные скобки — <code>[]</code></h3>
                <p>Квадратные скобки позволяют указать набор допустимых символов.</p>
                <div class="terminal-example">
                    <pre>d[iou]g</pre>
                </div>
                <p>Этот шаблон совпадёт со словами: <code>dig</code>, <code>dog</code>, <code>dug</code>.</p>
        
                <p>Если внутри скобок используется символ <code>^</code> в начале, это означает «любой символ, кроме перечисленных»:</p>
                <div class="terminal-example">
                    <pre>d[^i]g</pre>
                </div>
                <p>Такой шаблон совпадёт с <code>dog</code> и <code>dug</code>, но <strong>не</strong> с <code>dig</code>.</p>
        
                <h3>Диапазоны символов</h3>
                <p>Внутри скобок можно использовать диапазоны:</p>
                <div class="terminal-example">
                    <pre>d[a-c]g</pre>
                </div>
                <p>Этот шаблон совпадёт с <code>dag</code>, <code>dbg</code>, <code>dcg</code>.</p>
        
                <p>⚠️ Важно: скобки чувствительны к регистру!</p>
                <div class="terminal-example">
                    <pre>d[A-C]g</pre>
                </div>
                <p>Этот шаблон найдёт <code>dAg</code>, <code>dBg</code>, <code>dCg</code>, но <strong>не</strong> <code>dag</code>, <code>dbg</code> или <code>dcg</code>.</p>
        
                <p>Вот и всё — вы познакомились с основами регулярных выражений!</p>
            `
        },
        {
            id: 2,
            title: 'Редакторы текста',
            content: `
                <h2>Войны редакторов: Vim vs Emacs</h2>
                <p>Если собрать в одной комнате пару закоренелых пользователей Linux и спросить их, какой текстовый редактор лучше, вы станете свидетелем бесконечных споров о божественности то Vim, то Emacs. Даже не пытайтесь завести речь о графических редакторах, если вам дорога жизнь.</p>
                <p>Vim и Emacs — это популярные текстовые редакторы, которые по умолчанию установлены в большинстве дистрибутивов Linux. У каждого из них есть свои преимущества и недостатки. Если вы хотите управляться с системой как ниндзя, вам нужно освоить один из этих редакторов. По сути, они представляют собой универсальные инструменты для программирования, обработки текстовых документов и практически любых задач редактирования.</p>
            `
        }
    ];

    const usersContent = [
        {
            id: 1,
            title: 'Пользователи и группы',
            content: `
                <h2>Пользователи, группы и права доступа</h2>
                <p>В любой традиционной операционной системе существуют пользователи и группы. Они существуют исключительно для управления доступом и разрешениями. При запуске процесс выполняется от имени своего владельца, будь то Jane или Bob. Доступ к файлам и права собственности также зависят от разрешений. Вам бы не хотелось, чтобы Jane видела документы Bob, и наоборот.</p>
                <p>Каждый пользователь имеет свой домашний каталог, где хранятся его личные файлы. Обычно он находится в <code>/home/username</code>, но может отличаться в различных дистрибутивах.</p>
                <p>Система использует идентификаторы пользователей (UID) для управления учётными записями. Имена пользователей — это удобный способ связывания пользователей с идентификацией, но система идентифицирует пользователей по их UID. Система также использует группы для управления разрешениями. Группы — это просто наборы пользователей с правами, заданными для этой группы. Система идентифицирует их по их групповому ID (GID).</p>
        
                <p>В Linux, помимо обычных людей, использующих систему, существуют системные пользователи. Иногда эти пользователи являются системными демонами, которые постоянно выполняют процессы для поддержания функционирования системы. Одним из самых важных пользователей является <strong>root</strong> или суперпользователь. Root — самый мощный пользователь в системе, он может получить доступ к любому файлу и запускать или завершать любые процессы. По этой причине работать под root всё время может быть опасно — вы можете случайно удалить системно важные файлы. К счастью, если требуются права root и пользователь имеет к ним доступ, он может выполнить команду от имени root с помощью команды <code>sudo</code>. Команда <code>sudo</code> (superuser do) используется для выполнения команд с правами root. Мы подробнее рассмотрим, как пользователь получает доступ root, в следующем уроке.</p>
        
                <p>Попробуйте посмотреть содержимое защищённого файла, например <code>/etc/shadow</code>:</p>
        
                <div class="terminal-example">
                    <pre>$ cat /etc/shadow</pre>
                </div>
        
                <p>Обратите внимание, что вы получаете ошибку "permission denied". Посмотрите на права доступа с помощью:</p>
        
                <div class="terminal-example">
                    <pre>$ ls -la /etc/shadow<br><br>-rw-r----- 1 root shadow 1134 Dec 1 11:45 /etc/shadow</pre>
                </div>
        
                <p>Мы ещё не разбирали права доступа подробно, но что здесь происходит: root является владельцем файла, и вам нужен доступ root или членство в группе shadow, чтобы прочитать содержимое. Теперь выполните команду с sudo:</p>
        
                <div class="terminal-example">
                    <pre>$ sudo cat /etc/shadow</pre>
                </div>
        
                <p>Теперь вы сможете увидеть содержимое файла!</p>
            `
        },
        {
            id: 2,
            title: 'root',
            content: `
                <h2>Доступ суперпользователя: su и sudo</h2>
                <p>Мы рассмотрели один способ получения прав суперпользователя с помощью команды <code>sudo</code>. Также вы можете выполнять команды от имени суперпользователя с помощью команды <code>su</code>. Эта команда "подменяет пользователя" (substitute users) и открывает root-оболочку, если имя пользователя не указано. Вы можете использовать эту команду для переключения на любого пользователя, если знаете его пароль.</p>
    
                <div class="terminal-example">
                    <pre>$ su</pre>
                </div>
        
                <p>У этого метода есть недостатки: гораздо проще совершить критическую ошибку, выполняя все команды от root, у вас не будет записи команд, которые вы использовали для изменения системных конфигураций, и так далее. В основном, если вам нужно выполнять команды от имени суперпользователя, лучше придерживаться <code>sudo</code>.</p>
        
                <p>Теперь, когда вы знаете, какие команды выполнять от имени суперпользователя, возникает вопрос: как система узнает, у кого есть доступ к этим командам? Система не позволяет каждому встречному-поперечному выполнять команды от имени суперпользователя, так как же она это определяет? Существует файл <code>/etc/sudoers</code>, который содержит список пользователей, имеющих право выполнять <code>sudo</code>. Вы можете редактировать этот файл с помощью команды <code>visudo</code>.</p>
            `
        }
    ];

    const permissionsContent = [
        {
            id: 1,
            title: 'Разрешения файлов',
            content: `
                <h2>Права доступа к файлам</h2>
                <p>Как мы узнали ранее, файлы имеют различные разрешения или режимы доступа. Рассмотрим пример:</p>
    
                <div class="terminal-example">
                    <pre>$ ls -l Desktop/<br><br>drwxr-xr-x 2 pete penguins 4096 Dec 1 11:45 .</pre>
                </div>
        
                <p>Права доступа файла состоят из четырёх частей. Первая часть — это тип файла, который обозначается первым символом в правах доступа. В нашем случае, поскольку мы смотрим на каталог, отображается <code>d</code> для типа файла. Чаще всего вы будете видеть <code>-</code> для обычного файла.</p>
        
                <p>Следующие три части режима файла — это собственно права доступа. Права сгруппированы по 3 бита каждая. Первые 3 бита — права пользователя, затем права группы и, наконец, права остальных. Я добавил разделители, чтобы было легче различить:</p>
        
                <div class="terminal-example">
                    <pre>d | rwx | r-x | r-x</pre>
                </div>
        
                <p>Каждый символ представляет определённое право:</p>
        
                <ul>
                    <li><strong>r</strong>: чтение (readable)</li>
                    <li><strong>w</strong>: запись (writable)</li>
                    <li><strong>x</strong>: выполнение (executable, по сути — исполняемая программа)</li>
                    <li><strong>-</strong>: отсутствие права</li>
                </ul>
        
                <p>Таким образом, в приведённом выше примере мы видим, что пользователь pete имеет права на чтение, запись и выполнение для этого файла. Группа penguins имеет права на чтение и выполнение. И, наконец, остальные пользователи (все остальные) также имеют права на чтение и выполнение.</p>
            `
        }
    ];

    const processesContent = [
        {
            id: 1,
            title: 'ps',
            content: `
                <h2>Управление процессами</h2>
                <p>Процессы — это программы, выполняющиеся на вашей машине. Они управляются ядром, и каждый процесс имеет связанный с ним идентификатор, называемый PID (Process ID). Этот PID назначается в порядке создания процессов.</p>
    
    
                <p>Выполните команду <code>ps</code>, чтобы увидеть список запущенных процессов:</p>
        
                <div class="terminal-example">
                    <pre>$ ps<br><br>PID        TTY     STAT   TIME          CMD<br>41230    pts/4    Ss        00:00:00     bash<br>51224    pts/4    R+        00:00:00     ps</pre>
                </div>
        
                <p>Эта команда показывает краткий снимок текущих процессов:</p>
        
                <ul>
                    <li><strong>PID</strong>: Идентификатор процесса</li>
                    <li><strong>TTY</strong>: Управляющий терминал, связанный с процессом</li>
                    <li><strong>STAT</strong>: Код статуса процесса</li>
                    <li><strong>TIME</strong>: Общее время использования CPU</li>
                    <li><strong>CMD</strong>: Имя исполняемого файла/команды</li>
                </ul>
        
                <p>Если вы посмотрите man-страницу для <code>ps</code>, вы увидите множество опций, которые можно передать команде. Они различаются в зависимости от стиля — BSD, GNU или Unix. На мой взгляд, стиль BSD более популярен, поэтому мы будем использовать его. Если вам интересно, разница между стилями заключается в количестве дефисов и используемых флагах.</p>
        
                <div class="terminal-example">
                    <pre>$ ps aux</pre>
                </div>
        
                <p>Опция <code>a</code> отображает все процессы, включая те, которые выполняются другими пользователями. Опция <code>u</code> показывает более подробную информацию о процессах. И наконец, опция <code>x</code> выводит все процессы, не связанные с TTY — эти программы будут показывать <code>?</code> в поле TTY, они чаще всего встречаются среди демон-процессов, запускаемых при загрузке системы.</p>
        
                <p>Теперь вы видите гораздо больше полей. Не нужно запоминать их все — в продвинутом курсе по процессам мы рассмотрим некоторые из них снова:</p>
        
                <ul>
                    <li><strong>USER</strong>: Эффективный пользователь (от чьего имени выполняется доступ)</li>
                    <li><strong>PID</strong>: Идентификатор процесса</li>
                    <li><strong>%CPU</strong>: Время использования CPU, делённое на время работы процесса</li>
                    <li><strong>%MEM</strong>: Отношение резидентного размера процесса к физической памяти машины</li>
                    <li><strong>VSZ</strong>: Использование виртуальной памяти всего процесса</li>
                    <li><strong>RSS</strong>: Resident Set Size, невыгружаемая физическая память, используемая задачей</li>
                    <li><strong>TTY</strong>: Управляющий терминал, связанный с процессом</li>
                    <li><strong>STAT</strong>: Код статуса процесса</li>
                    <li><strong>START</strong>: Время начала процесса</li>
                    <li><strong>TIME</strong>: Общее время использования CPU</li>
                    <li><strong>COMMAND</strong>: Имя исполняемого файла/команды</li>
                </ul>
        
                <p>Вывод команды <code>ps</code> может быть немного перегруженным. Пока что мы чаще всего будем смотреть на поля PID, STAT и COMMAND.</p>
        
                <p>Ещё одна очень полезная команда — <code>top</code>. Команда <code>top</code> предоставляет информацию о процессах в реальном времени вместо статического снимка. По умолчанию обновление происходит каждые 10 секунд. <code>Top</code> — чрезвычайно полезный инструмент для определения процессов, потребляющих много ресурсов.</p>
        
                <div class="terminal-example">
                    <pre>$ top</pre>
                </div>
            `
        },
        {
            id: 2,
            title: 'Управляющий терминал',
            content: `
                <h2>TTY и управляющие терминалы процессов</h2>
                <p>Мы обсуждали наличие поля TTY в выводе команды <code>ps</code>. TTY — это терминал, который выполнил команду.</p>
    
                <p>Существует два типа терминалов: обычные терминальные устройства и псевдотерминальные устройства. Обычное терминальное устройство — это нативное терминальное устройство, в которое можно вводить данные и отправлять вывод в вашу систему. Это похоже на терминальное приложение, которое вы запускаете для доступа к оболочке, но это не совсем то же самое.</p>
        
                <p>Давайте сделаем небольшое отступление, чтобы увидеть это в действии. Нажмите Ctrl-Alt-F1, чтобы перейти в TTY1 (первую виртуальную консоль). Вы заметите, что там нет ничего, кроме терминала — никакой графики и т.д. Это считается обычным терминальным устройством. Вы можете выйти из него, нажав Ctrl-Alt-F7.</p>
        
                <p>Псевдотерминал — это то, в чем вы привыкли работать. Они эмулируют терминалы в окне shell-терминала и обозначаются как <code>PTS</code>. Если вы снова посмотрите на вывод <code>ps</code>, вы увидите ваш shell-процесс под <code>pts/*</code>.</p>
        
                <p>Теперь вернёмся к понятию управляющего терминала. Обычно процессы привязаны к управляющему терминалу. Например, если вы запускали программу в окне вашей оболочки, такую как <code>find</code>, и закрыли это окно, ваш процесс также завершится.</p>
        
                <p>Существуют процессы, такие как демон-процессы (daemon processes) — это особые процессы, которые, по сути, поддерживают работу системы. Они часто запускаются при загрузке системы и обычно завершаются при её выключении. Они работают в фоновом режиме, и поскольку мы не хотим, чтобы эти специальные процессы завершались, они не привязаны к управляющему терминалу. В выводе <code>ps</code> TTY у них указывается как <code>?</code>, что означает отсутствие управляющего терминала.</p>
            `
        }
    ];

    const packagesContent = [
        {
            id: 1,
            title: 'Распространение программного обеспечения',
            content: `
                <h2>Управление пакетами</h2>
                <p>Ваша система состоит из множества пакетов, таких как интернет-браузеры, текстовые редакторы, медиаплееры и т.д. Этими пакетами управляют менеджеры пакетов, которые устанавливают и поддерживают программное обеспечение в системе. Однако не все пакеты устанавливаются через менеджеры пакетов — часто можно установить пакеты напрямую из их исходного кода (мы скоро к этому перейдём). Но в большинстве случаев вы будете использовать менеджер пакетов для установки программ. Наиболее распространённые типы пакетов — Debian (<code>.deb</code>) и Red Hat (<code>.rpm</code>). Пакеты в формате Debian используются в таких дистрибутивах, как Debian, Ubuntu, LinuxMint и др. Пакеты Red Hat встречаются в Red Hat Enterprise Linux, Fedora, CentOS и др.</p>
                    
    
                <p>Что такое пакеты? Вы можете знать их как Chrome, Photoshop и т.д., и это они и есть, но на самом деле это просто множество-множество файлов, скомпилированных в один. Люди (или иногда один человек), которые пишут это программное обеспечение, известны как <strong>upstream-поставщики</strong>. Они компилируют свой код и пишут инструкции по его установке. Эти upstream-поставщики работают над выпуском нового программного обеспечения и обновлением существующего. Когда они готовы выпустить его в мир, они отправляют свой пакет <strong>maintainer-ам пакетов</strong>, которые занимаются тем, чтобы доставить этот программный продукт в руки пользователей. Эти maintainer-ы пакетов проверяют, управляют и распространяют это программное обеспечение в форме пакетов.</p>
            `
        }
    ];

    const devicesContent = [
        {
            id: 1,
            title: '/dev директория',
            content: `
                <h2>Устройства и файлы устройств</h2>
                <p>Когда вы подключаете устройство к вашей машине, ему обычно нужен драйвер устройства для правильной работы. Вы можете взаимодействовать с драйверами устройств через файлы устройств или ноды устройств — это специальные файлы, которые выглядят как обычные файлы. Поскольку эти файлы устройств подобны обычным файлам, вы можете использовать такие программы, как <code>ls</code>, <code>cat</code> и др., для взаимодействия с ними. Эти файлы устройств обычно хранятся в каталоге <code>/dev</code>. Выполните <code>ls</code> в каталоге <code>/dev</code> на вашей системе, и вы увидите большое количество файлов устройств, присутствующих в системе.</p>
    
    
                <div class="terminal-example">
                    <pre>$ ls /dev</pre>
                </div>
        
                <p>Некоторые из этих устройств вы уже использовали и взаимодействовали с ними, например <code>/dev/null</code>. Помните, когда мы направляем вывод в <code>/dev/null</code>, ядро знает, что это устройство принимает все наши входные данные и просто отбрасывает их, поэтому ничего не возвращается.</p>
        
                <p>В старые времена, если вы хотели добавить устройство в свою систему, вы добавляли файл устройства в <code>/dev</code>, а потом, вероятно, забывали о нём. Повторите это несколько раз, и вы поймёте, в чём была проблема. Каталог <code>/dev</code> захламлялся статическими файлами устройств, которые вы давно обновили, перестали использовать и т.д. Кроме того, устройствам назначались файлы устройств в том порядке, в котором ядро их обнаруживало. Поэтому при каждой перезагрузке системы устройства могли получать разные файлы устройств в зависимости от времени их обнаружения.</p>
        
                <p>К счастью, мы больше не используем этот метод. Теперь у нас есть инструменты для динамического добавления и удаления устройств, которые в настоящее время используются в системе, и мы обсудим это в следующих уроках.</p>
            `
        }
    ];

    const filesystemContent = [
        {
            id: 1,
            title: 'Иерархия файловой системы',
            content: `
                <h2>Структура файловой системы Linux</h2>
                <p>К этому моменту вы, вероятно, хорошо знакомы со структурой каталогов вашей системы, а если нет — скоро познакомитесь. Файловые системы могут различаться по своей структуре, но в большинстве случаев они должны соответствовать стандарту иерархии файловых систем (Filesystem Hierarchy Standard).</p>
    
                <p>Выполните <code>ls -l /</code>, чтобы увидеть каталоги, перечисленные в корневом каталоге. Ваш список может отличаться от моего, но в основном каталоги должны выглядеть следующим образом:</p>
        
                <ul>
                    <li><strong>/</strong> - Корневой каталог всей иерархии файловой системы, всё находится внутри этого каталога.</li>
                    <li><strong>/bin</strong> - Основные готовые к выполнению программы (бинарные файлы), включая самые базовые команды, такие как <code>ls</code> и <code>cp</code>.</li>
                    <li><strong>/boot</strong> - Содержит файлы загрузчика ядра.</li>
                    <li><strong>/dev</strong> - Файлы устройств.</li>
                    <li><strong>/etc</strong> - Основной каталог конфигурации системы, должен содержать только конфигурационные файлы, а не бинарные файлы.</li>
                    <li><strong>/home</strong> - Персональные каталоги пользователей, содержит ваши документы, файлы, настройки и т.д.</li>
                    <li><strong>/lib</strong> - Содержит файлы библиотек, которые могут использовать бинарные файлы.</li>
                    <li><strong>/media</strong> - Используется как точка подключения для съёмных носителей, таких как USB-накопители.</li>
                    <li><strong>/mnt</strong> - Временно подключённые файловые системы.</li>
                    <li><strong>/opt</strong> - Дополнительные пакеты прикладного программного обеспечения.</li>
                    <li><strong>/proc</strong> - Информация о currently running processes.</li>
                    <li><strong>/root</strong> - Домашний каталог пользователя root.</li>
                    <li><strong>/run</strong> - Информация о работающей системе с момента последней загрузки.</li>
                    <li><strong>/sbin</strong> - Содержит основные системные бинарные файлы, обычно могут выполняться только пользователем root.</li>
                    <li><strong>/srv</strong> - Данные, специфичные для сайта, которые обслуживаются системой.</li>
                    <li><strong>/tmp</strong> - Хранилище для временных файлов.</li>
                    <li><strong>/usr</strong> - К сожалению, название может вводить в заблуждение. Чаще всего он не содержит пользовательские файлы в смысле домашней папки. Этот каталог предназначен для программ и утилит, установленных пользователем, однако это не означает, что вы не можете добавлять туда личные каталоги. Внутри этого каталога находятся подкаталоги /usr/bin, /usr/local и т.д.</li>
                    <li><strong>/var</strong> - Каталог для изменяемых данных, используется для системного журналирования, отслеживания пользователей, кэшей и т.д. В основном всё, что постоянно подвержено изменениям.</li>
                </ul>
            `
        }
    ];

    let currentLessons = [];

    function showLesson(id) {
        const lesson = currentLessons.find(lesson => lesson.id === id);
        const contentDiv = document.getElementById('lesson-content');
        if (lesson && contentDiv) {
            contentDiv.innerHTML = lesson.content;
        } else if (contentDiv) {
            contentDiv.innerHTML = '<p>Урок не найден.</p>';
        }
    }

    function loadCategory(category) {
        const lessonList = document.getElementById('lesson-list');
        if (!lessonList) return;

        switch (category) {
            case 'intro':
                currentLessons = introLessons;
                break;
            case 'terminal':
                currentLessons = terminalLessons;
                break;
            case 'textfu':
                currentLessons = textFuContent;
                break;
            case 'advanced-textfu':
                currentLessons = advancedTextFuContent;
                break;
            case 'user-management':
                currentLessons = usersContent;
                break;
            case 'permissions':
                currentLessons = permissionsContent;
                break;
            case 'processes':
                currentLessons = processesContent;
                break;
            case 'packages':
                currentLessons = packagesContent;
                break;
            case 'devices':
                currentLessons = devicesContent;
                break;
            case 'filesystem':
                currentLessons = filesystemContent;
                break;
            default:
                currentLessons = introLessons;
        }

        const titleEl = document.getElementById('sidebar-title');
        if (titleEl) {
            titleEl.textContent =
                category === 'intro' ? 'Начало' :
                    category === 'terminal' ? 'Командная строка' :
                        category === 'textfu' ? 'Текст-фу' :
                            category === 'advanced-textfu' ? 'Расширенный текст-фу' :
                                category === 'user-management' ? 'Управление пользователями' :
                                    category === 'permissions' ? 'Разрешения' :
                                        category === 'processes' ? 'Процессы' :
                                            category === 'packages' ? 'Пакеты' :
                                                category === 'devices' ? 'Устройства' :
                                                    category === 'filesystem' ? 'Файловая система' :
                                                        'Начало';
        }

        lessonList.innerHTML = '';
        currentLessons.forEach(lesson => {
            const li = document.createElement('li');
            const link = document.createElement('a');
            link.href = '#';
            link.textContent = lesson.title;
            link.addEventListener('click', (e) => {
                e.preventDefault();
                showLesson(lesson.id);
                const sidebar = document.querySelector('.sidebar');
                if (window.innerWidth <= 768 && sidebar) {
                    sidebar.classList.remove('open');
                }
            });
            li.appendChild(link);
            lessonList.appendChild(li);
        });

        if (currentLessons.length > 0) {
            showLesson(currentLessons[0].id);
        }
    }

    const urlParams = new URLSearchParams(window.location.search);
    const category = urlParams.get('category') || 'terminal';
    loadCategory(category);
});