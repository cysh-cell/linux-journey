document.addEventListener('DOMContentLoaded', () => {
    const introLessons = [
        {
            id: 1,
            title: "1. Что такое Linux?",
            content: `
                <h2>Что такое Linux?</h2>
                <p>Привет, новичок! Так ты решил погрузиться в удивительный мир под названием Linux? Впереди тебя ждёт прекрасное и увлекательное путешествие!</p>
                <p>Меня зовут Пингвин Пит, и я буду твоим проводником в этом пути. Давай начнём с небольшой предыстории о том, как появился Linux.</p>
    
                <p>Чтобы понять, откуда взялся Linux, вернёмся к самому началу — к 1969 году, когда Кен Томпсон и Деннис Ритчи из Bell Laboratories разработали операционную систему UNIX. Позже её переписали на языке C, чтобы сделать более переносимой, и со временем она стала широко используемой ОС.</p>
    
                <p>Примерно десятилетие спустя Ричард Столлман начал работать над проектом GNU (GNU — это не UNIX), включавшим ядро под названием Hurd. К сожалению, это ядро так и не было завершено. Однако в рамках этого проекта была создана Стандартная общественная лицензия GNU (GPL) — лицензия свободного программного обеспечения.</p>
    
                <p>Ядро — это самая важная часть операционной системы. Именно оно позволяет «железу» общаться с программным обеспечением. Оно также выполняет множество других задач, но об этом мы поговорим в другом курсе. Пока что просто запомни: ядро управляет практически всем, что происходит в твоей системе.</p>
    
                <p>В то же время появлялись и другие проекты, такие как BSD, MINIX и другие, создававшие UNIX-подобные системы. Однако у всех этих UNIX-подобных систем была одна общая проблема — отсутствие единого, полноценного ядра.</p>
    
                <p>И тогда в 1991 году молодой человек по имени Линус Торвальдс начал разработку того, что сегодня мы знаем как ядро Linux.</p>
            `
        },
        {
            id: 2,
            title: "2. Выбор дистрибутива",
            content: `
                <h2>Выбор дистрибутива</h2>
                <p>В предыдущем уроке мы узнали о ядре Linux, которое ежедневно работает на миллионах устройств по всему миру.</p>
        
                <p>Прежде чем двигаться дальше, стоит уточнить один важный момент: термин «Linux» на самом деле — своего рода неточность. Строго говоря, Linux — это именно <strong>ядро</strong>. Однако большинство операционных систем, использующих это ядро, получили общее название — «Linux-дистрибутивы» или просто «Linux».</p>
        
                <p>Любая Linux-система состоит из трёх основных компонентов:</p>
        
                <ul>
                    <li><strong>Аппаратное обеспечение (Hardware)</strong> — всё «железо», на котором работает система: процессор, память, диски и другие устройства.</li>
                    <li><strong>Ядро Linux (Linux Kernel)</strong> — как мы уже говорили, это ядро операционной системы. Оно управляет оборудованием и определяет, как оно взаимодействует с программным обеспечением.</li>
                    <li><strong>Пользовательское пространство (User Space)</strong> — именно здесь вы, как пользователь, напрямую взаимодействуете с системой: запускаете приложения, работаете с файлами, настраиваете окружение.</li>
                </ul>
        
                <p>Теперь первый шаг, который вам предстоит сделать, — установить Linux на свой компьютер. У вас есть множество вариантов, и этот курс поможет разобраться в них и выбрать подходящий дистрибутив.</p>
        
                <p>Существует огромное количество Linux-дистрибутивов, но мы рассмотрим самые популярные из них.</p>
            `
        }
    ];

    const terminalLessons = [
        {
            id: 1,
            title: "1. Введение в командную строку",
            content: `
                <h2>Введение в командную строку</h2>
                <p>Мир — ваша устрица… или, точнее, оболочка (shell) — ваша устрица.</p>
        
                <p>Что такое оболочка? Оболочка — это программа, которая принимает ваши команды с клавиатуры и передаёт их операционной системе для выполнения. Если вы когда-либо пользовались графическим интерфейсом (GUI), то, скорее всего, видели программы вроде «Терминал» или «Консоль» — это просто приложения, запускающие для вас оболочку.</p>
        
                <p>Во всём этом курсе мы будем изучать удивительные возможности командной оболочки.</p>
        
                <p>Мы будем использовать оболочку <strong>bash</strong> (Bourne Again Shell). Почти все дистрибутивы Linux по умолчанию используют именно bash. Существуют и другие оболочки — например, ksh, zsh, tcsh — но мы не будем их рассматривать.</p>
        
                <p>Давайте начнём! В зависимости от дистрибутива внешний вид приглашения командной строки может отличаться, но в большинстве случаев оно соответствует следующему формату:</p>
        
                <div class="terminal-example">
                    <pre>username@hostname:current_directory<br>pete@icebox:/home/pete $</pre>
                </div>
        
                <p>Обратите внимание на символ <code>$</code> в конце приглашения? У разных оболочек разные приглашения. В нашем случае <code>$</code> означает, что вы работаете под обычным пользователем в оболочках Bash, Bourne или Korn. Когда вы вводите команду, <strong>не нужно</strong> набирать этот символ — он просто показывает, что система готова принимать ввод.</p>
        
                <p>Начнём с простой команды — <code>echo</code>. Эта команда просто выводит указанный текст на экран.</p>
        
                <div class="terminal-example">
                    <pre>$ echo Hello World</pre>
                </div>
            `
        },
        {
            id: 2,
            title: "2. Навигация по файловой системе",
            content: `
                <h2>Навигация по файловой системе</h2>
                <p>В Linux всё является файлом. По мере погружения в мир Linux вы всё глубже поймёте смысл этого утверждения, но пока просто запомните его.</p>
        
                <p>Все файлы организованы в иерархическое дерево каталогов. Самый первый каталог в файловой системе называется <strong>корневым каталогом</strong> (root directory) и обозначается символом <code>/</code>.</p>
        
                <p>В корневом каталоге находятся другие папки и файлы, внутри которых, в свою очередь, могут быть свои подкаталоги и файлы — и так далее. Вот пример структуры такого дерева:</p>
        
                <div class="terminal-example">
                    <pre>/
                        |-- bin
                        |   |-- file1
                        |   |-- file2
                        |-- etc
                        |   |-- file3
                        |   \`-- directory1
                        |       |-- file4
                        |       \`-- file5
                        |-- home
                        |-- var
                    </pre>
                </div>
        
                <p>Расположение файлов и каталогов называется <strong>путём</strong> (path). Например, если у вас есть папка <code>home</code>, внутри неё — папка <code>pete</code>, а внутри неё — папка <code>Movies</code>, то полный путь к ней будет выглядеть так:</p>
        
                <div class="terminal-example">
                    <pre>/home/pete/Movies</pre>
                </div>
        
                <p>Довольно просто, правда?</p>
        
                <p>Навигация по файловой системе, как и в реальной жизни, становится намного проще, если вы знаете, где находитесь и куда направляетесь.</p>
        
                <p>Чтобы узнать, в каком каталоге вы сейчас находитесь, используйте команду <code>pwd</code> (от англ. <em>print working directory</em> — «показать рабочий каталог»). Эта команда выводит полный путь к текущей директории, начиная от корня.</p>
        
                <div class="terminal-example">
                    <pre>$ pwd</pre>
                </div>
        
                <p>Где вы? Где я? Попробуйте выполнить эту команду сами!</p>
            `
        }
    ];

    const textFuContent = [
        {
            id: 1,
            title: 'stdout',
            content: `
                <h2>Перенаправление ввода-вывода (I/O)</h2>
                <p>К настоящему моменту мы уже познакомились со многими командами и их выводом, что подводит нас к следующей теме — потокам ввода-вывода (I/O). Давайте выполним следующую команду и разберем, как она работает.</p>
        
                <div class="terminal-example">
                    <pre>$ echo Hello World > peanuts.txt</pre>
                </div>
        
                <p>Что только что произошло? Проверьте каталог, в котором вы выполнили эту команду, и — о чудо! — вы должны увидеть файл с именем <code>peanuts.txt</code>. Загляните внутрь этого файла, и вы увидите текст <code>Hello World</code>. В одной команде произошло много всего, так что давайте разберём её по частям.</p>
        
                <p>Сначала разберём первую часть:</p>
        
                <div class="terminal-example">
                    <pre>$ echo Hello World</pre>
                </div>
        
                <p>Мы знаем, что эта команда выводит <code>Hello World</code> на экран, но как именно? Процессы используют потоки ввода-вывода для получения входных данных и возврата выходных. По умолчанию команда <code>echo</code> принимает ввод (стандартный ввод или <code>stdin</code>) с клавиатуры и возвращает вывод (стандартный вывод или <code>stdout</code>) на экран. Именно поэтому, когда вы вводите <code>echo Hello World</code> в оболочке, вы видите <code>Hello World</code> на экране. Однако перенаправление ввода-вывода позволяет изменить это поведение по умолчанию, предоставляя нам большую гибкость в работе с файлами.</p>
        
                <p>Перейдём к следующей части команды:</p>
        
                <div class="terminal-example">
                    <pre>></pre>
                </div>
        
                <p>Символ <code>></code> — это оператор перенаправления, который позволяет изменить назначение стандартного вывода. Он позволяет нам направить вывод команды <code>echo Hello World</code> в файл вместо экрана. Если файл ещё не существует, он будет создан. Однако, если файл уже существует, он будет перезаписан (в зависимости от используемой оболочки, вы можете добавить флаг, чтобы предотвратить это).</p>
        
                <p>И это, в общем-то, и есть принцип работы перенаправления стандартного вывода!</p>
        
                <p>Теперь представим, что я не хочу перезаписывать свой <code>peanuts.txt</code>. К счастью, для этого также существует оператор перенаправления — <code>>></code>:</p>
        
                <div class="terminal-example">
                    <pre>$ echo Hello World >> peanuts.txt</pre>
                </div>
        
                <p>Этот оператор <strong>добавит</strong> <code>Hello World</code> в конец файла <code>peanuts.txt</code>. Если файл ещё не существует, он будет создан, так же как при использовании оператора <code>></code>!</p>
            `
        },
        {
            id: 2,
            title: 'stdin',
            content: `
                <h2>Перенаправление стандартного ввода (stdin)</h2>
                <p>В предыдущем уроке мы узнали, что можем использовать различные потоки стандартного вывода, такие как файл или экран. Но существуют также различные потоки стандартного ввода (stdin), которые мы можем использовать. Мы знаем, что можем получать stdin с таких устройств, как клавиатура, но мы также можем использовать файлы, вывод других процессов и терминал. Давайте рассмотрим пример.</p>

                <p>Воспользуемся файлом <code>peanuts.txt</code> из предыдущего урока — помните, в нём был текст <code>Hello World</code>.</p>
        
                <div class="terminal-example">
                    <pre>$ cat < peanuts.txt > banana.txt</pre>
                </div>
        
                <p>Так же, как у нас есть <code>></code> для перенаправления stdout, мы можем использовать <code><</code> для перенаправления stdin.</p>
        
                <p>Обычно в команде <code>cat</code> вы передаёте ей файл, и этот файл становится stdin. В данном случае мы перенаправили <code>peanuts.txt</code> как наш stdin. Затем вывод команды <code>cat peanuts.txt</code> (который будет <code>Hello World</code>) перенаправляется в другой файл с именем <code>banana.txt</code>.</p>
            `
        }
    ];

    const advancedTextFuContent = [
        {
            id: 1,
            title: 'regex',
            content: `
                <h2>Регулярные выражения</h2>
                <p>Регулярные выражения — это мощный инструмент для поиска и выбора текста на основе шаблонов. Они используют специальные обозначения, похожие на уже знакомые нам, например, подстановочный символ <code>*</code>.</p>
        
                <p>Мы рассмотрим несколько самых распространённых конструкций регулярных выражений. Эти правила почти универсальны и работают в большинстве языков программирования.</p>
        
                <p>В качестве тестовой строки будем использовать следующий текст:</p>
        
                <div class="terminal-example">
                    <pre>sally sells seashells<br>by the seashore</pre>
                </div>
        
                <h3>1. Начало строки — <code>^</code></h3>
                <p>Символ <code>^</code> означает «начало строки».</p>
                <div class="terminal-example">
                    <pre>^by</pre>
                </div>
                <p>Этот шаблон найдёт строку <code>by the seashore</code>, потому что она начинается с <code>by</code>.</p>
        
                <h3>2. Конец строки — <code>$</code></h3>
                <p>Символ <code>$</code> означает «конец строки».</p>
                <div class="terminal-example">
                    <pre>seashore$</pre>
                </div>
                <p>Этот шаблон также совпадёт со строкой <code>by the seashore</code>, так как она заканчивается на <code>seashore</code>.</p>
        
                <h3>3. Любой символ — <code>.</code></h3>
                <p>Точка <code>.</code> соответствует любому одному символу.</p>
                <div class="terminal-example">
                    <pre>b.</pre>
                </div>
                <p>Этот шаблон совпадёт с <code>by</code>, потому что <code>b</code> + любой символ = <code>by</code>.</p>
        
                <h3>4. Квадратные скобки — <code>[]</code></h3>
                <p>Квадратные скобки позволяют указать набор допустимых символов.</p>
                <div class="terminal-example">
                    <pre>d[iou]g</pre>
                </div>
                <p>Этот шаблон совпадёт со словами: <code>dig</code>, <code>dog</code>, <code>dug</code>.</p>
        
                <p>Если внутри скобок используется символ <code>^</code> в начале, это означает «любой символ, кроме перечисленных»:</p>
                <div class="terminal-example">
                    <pre>d[^i]g</pre>
                </div>
                <p>Такой шаблон совпадёт с <code>dog</code> и <code>dug</code>, но <strong>не</strong> с <code>dig</code>.</p>
        
                <h3>Диапазоны символов</h3>
                <p>Внутри скобок можно использовать диапазоны:</p>
                <div class="terminal-example">
                    <pre>d[a-c]g</pre>
                </div>
                <p>Этот шаблон совпадёт с <code>dag</code>, <code>dbg</code>, <code>dcg</code>.</p>
        
                <p>⚠️ Важно: скобки чувствительны к регистру!</p>
                <div class="terminal-example">
                    <pre>d[A-C]g</pre>
                </div>
                <p>Этот шаблон найдёт <code>dAg</code>, <code>dBg</code>, <code>dCg</code>, но <strong>не</strong> <code>dag</code>, <code>dbg</code> или <code>dcg</code>.</p>
        
                <p>Вот и всё — вы познакомились с основами регулярных выражений!</p>
            `
        },
        {
            id: 2,
            title: 'Редакторы текста',
            content: `
                <h2>Войны редакторов: Vim vs Emacs</h2>
                <p>Если собрать в одной комнате пару закоренелых пользователей Linux и спросить их, какой текстовый редактор лучше, вы станете свидетелем бесконечных споров о божественности то Vim, то Emacs. Даже не пытайтесь завести речь о графических редакторах, если вам дорога жизнь.</p>
                <p>Vim и Emacs — это популярные текстовые редакторы, которые по умолчанию установлены в большинстве дистрибутивов Linux. У каждого из них есть свои преимущества и недостатки. Если вы хотите управляться с системой как ниндзя, вам нужно освоить один из этих редакторов. По сути, они представляют собой универсальные инструменты для программирования, обработки текстовых документов и практически любых задач редактирования.</p>
            `
        }
    ];

    const usersContent = [
        {
            id: 1,
            title: 'Пользователи и группы',
            content: `
                <h2>Пользователи, группы и права доступа</h2>
                <p>В любой традиционной операционной системе существуют пользователи и группы. Они существуют исключительно для управления доступом и разрешениями. При запуске процесс выполняется от имени своего владельца, будь то Jane или Bob. Доступ к файлам и права собственности также зависят от разрешений. Вам бы не хотелось, чтобы Jane видела документы Bob, и наоборот.</p>
                <p>Каждый пользователь имеет свой домашний каталог, где хранятся его личные файлы. Обычно он находится в <code>/home/username</code>, но может отличаться в различных дистрибутивах.</p>
                <p>Система использует идентификаторы пользователей (UID) для управления учётными записями. Имена пользователей — это удобный способ связывания пользователей с идентификацией, но система идентифицирует пользователей по их UID. Система также использует группы для управления разрешениями. Группы — это просто наборы пользователей с правами, заданными для этой группы. Система идентифицирует их по их групповому ID (GID).</p>
        
                <p>В Linux, помимо обычных людей, использующих систему, существуют системные пользователи. Иногда эти пользователи являются системными демонами, которые постоянно выполняют процессы для поддержания функционирования системы. Одним из самых важных пользователей является <strong>root</strong> или суперпользователь. Root — самый мощный пользователь в системе, он может получить доступ к любому файлу и запускать или завершать любые процессы. По этой причине работать под root всё время может быть опасно — вы можете случайно удалить системно важные файлы. К счастью, если требуются права root и пользователь имеет к ним доступ, он может выполнить команду от имени root с помощью команды <code>sudo</code>. Команда <code>sudo</code> (superuser do) используется для выполнения команд с правами root. Мы подробнее рассмотрим, как пользователь получает доступ root, в следующем уроке.</p>
        
                <p>Попробуйте посмотреть содержимое защищённого файла, например <code>/etc/shadow</code>:</p>
        
                <div class="terminal-example">
                    <pre>$ cat /etc/shadow</pre>
                </div>
        
                <p>Обратите внимание, что вы получаете ошибку "permission denied". Посмотрите на права доступа с помощью:</p>
        
                <div class="terminal-example">
                    <pre>$ ls -la /etc/shadow<br><br>-rw-r----- 1 root shadow 1134 Dec 1 11:45 /etc/shadow</pre>
                </div>
        
                <p>Мы ещё не разбирали права доступа подробно, но что здесь происходит: root является владельцем файла, и вам нужен доступ root или членство в группе shadow, чтобы прочитать содержимое. Теперь выполните команду с sudo:</p>
        
                <div class="terminal-example">
                    <pre>$ sudo cat /etc/shadow</pre>
                </div>
        
                <p>Теперь вы сможете увидеть содержимое файла!</p>
            `
        },
        {
            id: 2,
            title: 'root',
            content: `
                <h2>Доступ суперпользователя: su и sudo</h2>
                <p>Мы рассмотрели один способ получения прав суперпользователя с помощью команды <code>sudo</code>. Также вы можете выполнять команды от имени суперпользователя с помощью команды <code>su</code>. Эта команда "подменяет пользователя" (substitute users) и открывает root-оболочку, если имя пользователя не указано. Вы можете использовать эту команду для переключения на любого пользователя, если знаете его пароль.</p>
    
                <div class="terminal-example">
                    <pre>$ su</pre>
                </div>
        
                <p>У этого метода есть недостатки: гораздо проще совершить критическую ошибку, выполняя все команды от root, у вас не будет записи команд, которые вы использовали для изменения системных конфигураций, и так далее. В основном, если вам нужно выполнять команды от имени суперпользователя, лучше придерживаться <code>sudo</code>.</p>
        
                <p>Теперь, когда вы знаете, какие команды выполнять от имени суперпользователя, возникает вопрос: как система узнает, у кого есть доступ к этим командам? Система не позволяет каждому встречному-поперечному выполнять команды от имени суперпользователя, так как же она это определяет? Существует файл <code>/etc/sudoers</code>, который содержит список пользователей, имеющих право выполнять <code>sudo</code>. Вы можете редактировать этот файл с помощью команды <code>visudo</code>.</p>
            `
        }
    ];

    const permissionsContent = [
        {
            id: 1,
            title: 'Разрешения файлов',
            content: `
                <h2>Права доступа к файлам</h2>
                <p>Как мы узнали ранее, файлы имеют различные разрешения или режимы доступа. Рассмотрим пример:</p>
    
                <div class="terminal-example">
                    <pre>$ ls -l Desktop/<br><br>drwxr-xr-x 2 pete penguins 4096 Dec 1 11:45 .</pre>
                </div>
        
                <p>Права доступа файла состоят из четырёх частей. Первая часть — это тип файла, который обозначается первым символом в правах доступа. В нашем случае, поскольку мы смотрим на каталог, отображается <code>d</code> для типа файла. Чаще всего вы будете видеть <code>-</code> для обычного файла.</p>
        
                <p>Следующие три части режима файла — это собственно права доступа. Права сгруппированы по 3 бита каждая. Первые 3 бита — права пользователя, затем права группы и, наконец, права остальных. Я добавил разделители, чтобы было легче различить:</p>
        
                <div class="terminal-example">
                    <pre>d | rwx | r-x | r-x</pre>
                </div>
        
                <p>Каждый символ представляет определённое право:</p>
        
                <ul>
                    <li><strong>r</strong>: чтение (readable)</li>
                    <li><strong>w</strong>: запись (writable)</li>
                    <li><strong>x</strong>: выполнение (executable, по сути — исполняемая программа)</li>
                    <li><strong>-</strong>: отсутствие права</li>
                </ul>
        
                <p>Таким образом, в приведённом выше примере мы видим, что пользователь pete имеет права на чтение, запись и выполнение для этого файла. Группа penguins имеет права на чтение и выполнение. И, наконец, остальные пользователи (все остальные) также имеют права на чтение и выполнение.</p>
            `
        }
    ];

    const processesContent = [
        {
            id: 1,
            title: 'ps',
            content: `
                <h2>Управление процессами</h2>
                <p>Процессы — это программы, выполняющиеся на вашей машине. Они управляются ядром, и каждый процесс имеет связанный с ним идентификатор, называемый PID (Process ID). Этот PID назначается в порядке создания процессов.</p>
    
    
                <p>Выполните команду <code>ps</code>, чтобы увидеть список запущенных процессов:</p>
        
                <div class="terminal-example">
                    <pre>$ ps<br><br>PID        TTY     STAT   TIME          CMD<br>41230    pts/4    Ss        00:00:00     bash<br>51224    pts/4    R+        00:00:00     ps</pre>
                </div>
        
                <p>Эта команда показывает краткий снимок текущих процессов:</p>
        
                <ul>
                    <li><strong>PID</strong>: Идентификатор процесса</li>
                    <li><strong>TTY</strong>: Управляющий терминал, связанный с процессом</li>
                    <li><strong>STAT</strong>: Код статуса процесса</li>
                    <li><strong>TIME</strong>: Общее время использования CPU</li>
                    <li><strong>CMD</strong>: Имя исполняемого файла/команды</li>
                </ul>
        
                <p>Если вы посмотрите man-страницу для <code>ps</code>, вы увидите множество опций, которые можно передать команде. Они различаются в зависимости от стиля — BSD, GNU или Unix. На мой взгляд, стиль BSD более популярен, поэтому мы будем использовать его. Если вам интересно, разница между стилями заключается в количестве дефисов и используемых флагах.</p>
        
                <div class="terminal-example">
                    <pre>$ ps aux</pre>
                </div>
        
                <p>Опция <code>a</code> отображает все процессы, включая те, которые выполняются другими пользователями. Опция <code>u</code> показывает более подробную информацию о процессах. И наконец, опция <code>x</code> выводит все процессы, не связанные с TTY — эти программы будут показывать <code>?</code> в поле TTY, они чаще всего встречаются среди демон-процессов, запускаемых при загрузке системы.</p>
        
                <p>Теперь вы видите гораздо больше полей. Не нужно запоминать их все — в продвинутом курсе по процессам мы рассмотрим некоторые из них снова:</p>
        
                <ul>
                    <li><strong>USER</strong>: Эффективный пользователь (от чьего имени выполняется доступ)</li>
                    <li><strong>PID</strong>: Идентификатор процесса</li>
                    <li><strong>%CPU</strong>: Время использования CPU, делённое на время работы процесса</li>
                    <li><strong>%MEM</strong>: Отношение резидентного размера процесса к физической памяти машины</li>
                    <li><strong>VSZ</strong>: Использование виртуальной памяти всего процесса</li>
                    <li><strong>RSS</strong>: Resident Set Size, невыгружаемая физическая память, используемая задачей</li>
                    <li><strong>TTY</strong>: Управляющий терминал, связанный с процессом</li>
                    <li><strong>STAT</strong>: Код статуса процесса</li>
                    <li><strong>START</strong>: Время начала процесса</li>
                    <li><strong>TIME</strong>: Общее время использования CPU</li>
                    <li><strong>COMMAND</strong>: Имя исполняемого файла/команды</li>
                </ul>
        
                <p>Вывод команды <code>ps</code> может быть немного перегруженным. Пока что мы чаще всего будем смотреть на поля PID, STAT и COMMAND.</p>
        
                <p>Ещё одна очень полезная команда — <code>top</code>. Команда <code>top</code> предоставляет информацию о процессах в реальном времени вместо статического снимка. По умолчанию обновление происходит каждые 10 секунд. <code>Top</code> — чрезвычайно полезный инструмент для определения процессов, потребляющих много ресурсов.</p>
        
                <div class="terminal-example">
                    <pre>$ top</pre>
                </div>
            `
        },
        {
            id: 2,
            title: 'Управляющий терминал',
            content: `
                <h2>TTY и управляющие терминалы процессов</h2>
                <p>Мы обсуждали наличие поля TTY в выводе команды <code>ps</code>. TTY — это терминал, который выполнил команду.</p>
    
                <p>Существует два типа терминалов: обычные терминальные устройства и псевдотерминальные устройства. Обычное терминальное устройство — это нативное терминальное устройство, в которое можно вводить данные и отправлять вывод в вашу систему. Это похоже на терминальное приложение, которое вы запускаете для доступа к оболочке, но это не совсем то же самое.</p>
        
                <p>Давайте сделаем небольшое отступление, чтобы увидеть это в действии. Нажмите Ctrl-Alt-F1, чтобы перейти в TTY1 (первую виртуальную консоль). Вы заметите, что там нет ничего, кроме терминала — никакой графики и т.д. Это считается обычным терминальным устройством. Вы можете выйти из него, нажав Ctrl-Alt-F7.</p>
        
                <p>Псевдотерминал — это то, в чем вы привыкли работать. Они эмулируют терминалы в окне shell-терминала и обозначаются как <code>PTS</code>. Если вы снова посмотрите на вывод <code>ps</code>, вы увидите ваш shell-процесс под <code>pts/*</code>.</p>
        
                <p>Теперь вернёмся к понятию управляющего терминала. Обычно процессы привязаны к управляющему терминалу. Например, если вы запускали программу в окне вашей оболочки, такую как <code>find</code>, и закрыли это окно, ваш процесс также завершится.</p>
        
                <p>Существуют процессы, такие как демон-процессы (daemon processes) — это особые процессы, которые, по сути, поддерживают работу системы. Они часто запускаются при загрузке системы и обычно завершаются при её выключении. Они работают в фоновом режиме, и поскольку мы не хотим, чтобы эти специальные процессы завершались, они не привязаны к управляющему терминалу. В выводе <code>ps</code> TTY у них указывается как <code>?</code>, что означает отсутствие управляющего терминала.</p>
            `
        }
    ];

    const packagesContent = [
        {
            id: 1,
            title: 'Распространение программного обеспечения',
            content: `
                <h2>Управление пакетами</h2>
                <p>Ваша система состоит из множества пакетов, таких как интернет-браузеры, текстовые редакторы, медиаплееры и т.д. Этими пакетами управляют менеджеры пакетов, которые устанавливают и поддерживают программное обеспечение в системе. Однако не все пакеты устанавливаются через менеджеры пакетов — часто можно установить пакеты напрямую из их исходного кода (мы скоро к этому перейдём). Но в большинстве случаев вы будете использовать менеджер пакетов для установки программ. Наиболее распространённые типы пакетов — Debian (<code>.deb</code>) и Red Hat (<code>.rpm</code>). Пакеты в формате Debian используются в таких дистрибутивах, как Debian, Ubuntu, LinuxMint и др. Пакеты Red Hat встречаются в Red Hat Enterprise Linux, Fedora, CentOS и др.</p>
                    
    
                <p>Что такое пакеты? Вы можете знать их как Chrome, Photoshop и т.д., и это они и есть, но на самом деле это просто множество-множество файлов, скомпилированных в один. Люди (или иногда один человек), которые пишут это программное обеспечение, известны как <strong>upstream-поставщики</strong>. Они компилируют свой код и пишут инструкции по его установке. Эти upstream-поставщики работают над выпуском нового программного обеспечения и обновлением существующего. Когда они готовы выпустить его в мир, они отправляют свой пакет <strong>maintainer-ам пакетов</strong>, которые занимаются тем, чтобы доставить этот программный продукт в руки пользователей. Эти maintainer-ы пакетов проверяют, управляют и распространяют это программное обеспечение в форме пакетов.</p>
            `
        }
    ];

    const devicesContent = [
        {
            id: 1,
            title: '/dev директория',
            content: `
                <h2>Устройства и файлы устройств</h2>
                <p>Когда вы подключаете устройство к вашей машине, ему обычно нужен драйвер устройства для правильной работы. Вы можете взаимодействовать с драйверами устройств через файлы устройств или ноды устройств — это специальные файлы, которые выглядят как обычные файлы. Поскольку эти файлы устройств подобны обычным файлам, вы можете использовать такие программы, как <code>ls</code>, <code>cat</code> и др., для взаимодействия с ними. Эти файлы устройств обычно хранятся в каталоге <code>/dev</code>. Выполните <code>ls</code> в каталоге <code>/dev</code> на вашей системе, и вы увидите большое количество файлов устройств, присутствующих в системе.</p>
    
    
                <div class="terminal-example">
                    <pre>$ ls /dev</pre>
                </div>
        
                <p>Некоторые из этих устройств вы уже использовали и взаимодействовали с ними, например <code>/dev/null</code>. Помните, когда мы направляем вывод в <code>/dev/null</code>, ядро знает, что это устройство принимает все наши входные данные и просто отбрасывает их, поэтому ничего не возвращается.</p>
        
                <p>В старые времена, если вы хотели добавить устройство в свою систему, вы добавляли файл устройства в <code>/dev</code>, а потом, вероятно, забывали о нём. Повторите это несколько раз, и вы поймёте, в чём была проблема. Каталог <code>/dev</code> захламлялся статическими файлами устройств, которые вы давно обновили, перестали использовать и т.д. Кроме того, устройствам назначались файлы устройств в том порядке, в котором ядро их обнаруживало. Поэтому при каждой перезагрузке системы устройства могли получать разные файлы устройств в зависимости от времени их обнаружения.</p>
        
                <p>К счастью, мы больше не используем этот метод. Теперь у нас есть инструменты для динамического добавления и удаления устройств, которые в настоящее время используются в системе, и мы обсудим это в следующих уроках.</p>
            `
        }
    ];

    const filesystemContent = [
        {
            id: 1,
            title: 'Иерархия файловой системы',
            content: `
                <h2>Структура файловой системы Linux</h2>
                <p>К этому моменту вы, вероятно, хорошо знакомы со структурой каталогов вашей системы, а если нет — скоро познакомитесь. Файловые системы могут различаться по своей структуре, но в большинстве случаев они должны соответствовать стандарту иерархии файловых систем (Filesystem Hierarchy Standard).</p>
    
                <p>Выполните <code>ls -l /</code>, чтобы увидеть каталоги, перечисленные в корневом каталоге. Ваш список может отличаться от моего, но в основном каталоги должны выглядеть следующим образом:</p>
        
                <ul>
                    <li><strong>/</strong> - Корневой каталог всей иерархии файловой системы, всё находится внутри этого каталога.</li>
                    <li><strong>/bin</strong> - Основные готовые к выполнению программы (бинарные файлы), включая самые базовые команды, такие как <code>ls</code> и <code>cp</code>.</li>
                    <li><strong>/boot</strong> - Содержит файлы загрузчика ядра.</li>
                    <li><strong>/dev</strong> - Файлы устройств.</li>
                    <li><strong>/etc</strong> - Основной каталог конфигурации системы, должен содержать только конфигурационные файлы, а не бинарные файлы.</li>
                    <li><strong>/home</strong> - Персональные каталоги пользователей, содержит ваши документы, файлы, настройки и т.д.</li>
                    <li><strong>/lib</strong> - Содержит файлы библиотек, которые могут использовать бинарные файлы.</li>
                    <li><strong>/media</strong> - Используется как точка подключения для съёмных носителей, таких как USB-накопители.</li>
                    <li><strong>/mnt</strong> - Временно подключённые файловые системы.</li>
                    <li><strong>/opt</strong> - Дополнительные пакеты прикладного программного обеспечения.</li>
                    <li><strong>/proc</strong> - Информация о currently running processes.</li>
                    <li><strong>/root</strong> - Домашний каталог пользователя root.</li>
                    <li><strong>/run</strong> - Информация о работающей системе с момента последней загрузки.</li>
                    <li><strong>/sbin</strong> - Содержит основные системные бинарные файлы, обычно могут выполняться только пользователем root.</li>
                    <li><strong>/srv</strong> - Данные, специфичные для сайта, которые обслуживаются системой.</li>
                    <li><strong>/tmp</strong> - Хранилище для временных файлов.</li>
                    <li><strong>/usr</strong> - К сожалению, название может вводить в заблуждение. Чаще всего он не содержит пользовательские файлы в смысле домашней папки. Этот каталог предназначен для программ и утилит, установленных пользователем, однако это не означает, что вы не можете добавлять туда личные каталоги. Внутри этого каталога находятся подкаталоги /usr/bin, /usr/local и т.д.</li>
                    <li><strong>/var</strong> - Каталог для изменяемых данных, используется для системного журналирования, отслеживания пользователей, кэшей и т.д. В основном всё, что постоянно подвержено изменениям.</li>
                </ul>
            `
        }
    ];

    const bootContent = [
        {
            id: 1,
            title: 'Обзор процесса загрузки',
            content: `
                <h2>Процесс загрузки Linux</h2>
                <p>Теперь, когда мы получили довольно хорошее представление о некоторых важных компонентах Linux, давайте соберём всё воедино, изучив процесс загрузки системы. Когда вы включаете компьютер, он выполняет несколько интересных действий: показывает экран с логотипом, проходит через различные сообщения и в конце выводит окно входа в систему. На самом деле между нажатием кнопки питания и входом в систему происходит огромное количество процессов, которые мы обсудим в этом курсе.</p>
    
                <p>Процесс загрузки Linux можно разбить на 4 простых этапа:</p>
        
                <h3>1. BIOS</h3>
                <p>BIOS (от "Basic Input/Output System" - базовая система ввода-вывода) инициализирует оборудование и с помощью самотестирования при включении (POST) проверяет, что всё оборудование готово к работе. Основная задача BIOS — загрузить загрузчик (bootloader).</p>
        
                <h3>2. Загрузчик (Bootloader)</h3>
                <p>Загрузчик загружает ядро в память и затем запускает ядро с набором параметров. Один из самых распространённых загрузчиков — GRUB, который является универсальным стандартом для Linux.</p>
        
                <h3>3. Ядро (Kernel)</h3>
                <p>Когда ядро загружено, оно немедленно инициализирует устройства и память. Основная задача ядра — загрузить процесс init.</p>
        
                <h3>4. Init</h3>
                <p>Помните, что процесс init — это первый процесс, который запускается в системе. Init запускает и останавливает основные сервисные процессы в системе. Существует три основные реализации init в дистрибутивах Linux. Мы кратко рассмотрим их здесь и подробнее изучим в другом курсе.</p>
        
                <p>Вот и всё — (очень) простое объяснение процесса загрузки Linux. Мы рассмотрим эти этапы более подробно в следующих уроках.</p>
            `
        }
    ];

    const kernelContent = [
        {
            id: 1,
            title: 'Обзор ядра',
            content: `
                <h2>Уровни абстракции операционной системы Linux</h2>
                <p>Как вы уже узнали, ядро является сердцем операционной системы. Мы говорили о других частях операционной системы, но ещё не показывали, как они все работают вместе. Операционную систему Linux можно организовать в три различных уровня абстракции.</p>
    
    
                <h3>Аппаратное обеспечение (Hardware)</h3>
                <p>Самый базовый уровень — это аппаратное обеспечение, которое включает наш CPU, память, жёсткие диски, сетевые порты и т.д. Это физический уровень, который фактически выполняет вычисления того, что делает наша машина.</p>
        
                <h3>Ядро (Kernel)</h3>
                <p>Следующий уровень — ядро, которое управляет процессами и памятью, обеспечивает взаимодействие с устройствами, обрабатывает системные вызовы, настраивает нашу файловую систему и т.д. Задача ядра — общаться с аппаратным обеспечением, чтобы гарантировать, что оно делает то, что мы хотим от наших процессов.</p>
        
                <h3>Пользовательское пространство (User Space)</h3>
                <p>И уровень, с которым вы знакомы, — это пользовательское пространство. Оно включает оболочку (shell), программы, которые вы запускаете, графику и т.д.</p>
        
                <p>В этом курсе мы сосредоточимся на ядре и изучим его особенности.</p>
            `
        }
    ];

    const initContent = [
        {
            id: 1,
            title: 'Обзор Системы V',
            content: `
                <h2>Система инициализации System V (Sys V)</h2>
                <p>Основное назначение init — запускать и останавливать основные процессы в системе. В Linux существует три основные реализации init: System V, Upstart и systemd. В этом уроке мы рассмотрим наиболее традиционную версию init — System V init или Sys V (произносится как "System Five").</p>
    
                <p>Чтобы определить, используете ли вы реализацию Sys V init, проверьте наличие файла <code>/etc/inittab</code> — если он есть, вы, скорее всего, используете Sys V.</p>
        
                <p>Sys V запускает и останавливает процессы последовательно. Например, если вы хотите запустить службу с именем foo-a, то для работы foo-b необходимо сначала убедиться, что foo-a уже работает. Sys V делает это с помощью скриптов — эти скрипты запускают и останавливают службы за нас. Мы можем писать собственные скрипты или, что чаще всего, использовать уже встроенные в операционную систему, которые используются для загрузки основных служб.</p>
        
                <p>Преимущество этой реализации init в том, что решать зависимости относительно легко, поскольку вы знаете, что foo-a должна запускаться перед foo-b. Однако производительность не очень высокая, поскольку обычно одна операция (запуск или остановка) выполняется за раз.</p>
        
                <p>При использовании Sys V состояние машины определяется уровнями выполнения (runlevels), которые устанавливаются от 0 до 6. Эти различные режимы могут отличаться в зависимости от дистрибутива, но чаще всего выглядят следующим образом:</p>
        
                <ul>
                    <li><strong>0</strong>: Выключение системы</li>
                    <li><strong>1</strong>: Однопользовательский режим</li>
                    <li><strong>2</strong>: Многопользовательский режим без сети</li>
                    <li><strong>3</strong>: Многопользовательский режим с сетью</li>
                    <li><strong>4</strong>: Не используется</li>
                    <li><strong>5</strong>: Многопользовательский режим с сетью и графическим интерфейсом</li>
                    <li><strong>6</strong>: Перезагрузка</li>
                </ul>
        
                <p>При запуске система проверяет, на каком уровне выполнения вы находитесь, и выполняет скрипты, расположенные в конфигурации этого уровня выполнения. Скрипты находятся в <code>/etc/rc.d/rc[номер уровня].d/</code> или <code>/etc/init.d</code>. Скрипты, начинающиеся с S (start) или K (kill), будут выполняться при запуске и выключении соответственно. Цифры рядом с этими символами обозначают последовательность их выполнения.</p>
        
                <p>Например:</p>
        
                <div class="terminal-example">
                    <pre>pete@icebox:/etc/rc.d/rc0.d$ ls<br><br>K10updates  K80openvpn</pre>
                </div>
        
                <p>Мы видим, что при переходе на уровень выполнения 0 (режим выключения) наша машина попытается выполнить скрипт для остановки службы updates, а затем openvpn. Чтобы узнать, на какой уровень выполнения загружается ваша машина, вы можете посмотреть уровень выполнения по умолчанию в файле <code>/etc/inittab</code>. Вы также можете изменить уровень выполнения по умолчанию в этом файле.</p>
        
                <p>Стоит отметить, что System V постепенно заменяется — возможно, не сегодня или даже через несколько лет. Однако вы можете встретить уровни выполнения в других реализациях init — это в основном для поддержки тех служб, которые запускаются или останавливаются только с помощью скриптов System V init.</p>
            `
        }
    ];

    const processContent = [
        {
            id: 1,
            title: 'Отслеживание процессов: верх',
            content: `
                <h2>Анализ использования ресурсов: команда top</h2>
                <p>В этом курсе мы рассмотрим, как читать и анализировать использование ресурсов в вашей системе. Этот урок показывает отличные инструменты для отслеживания действий процессов.</p>
    
    
                <h3>top</h3>
                <p>Мы уже обсуждали <code>top</code>, но теперь углубимся в детали того, что он фактически отображает. Помните, <code>top</code> — это инструмент, который мы использовали для получения реального представления об использовании системы нашими процессами:</p>
        
                <div class="terminal-example">
                    <pre>top - 18:06:26 up 6 days,  4:07,  2 users,  load average: 0.92, 0.62, 0.59<br>Tasks: 389 total,   1 running, 387 sleeping,   0 stopped,   1 zombie<br>%Cpu(s):  1.8 us,  0.4 sy,  0.0 ni, 97.6 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st<br>KiB Mem:  32870888 total, 27467976 used,  5402912 free,   518808 buffers<br>KiB Swap: 33480700 total,    39892 used, 33440808 free. 19454152 cached Mem<br><br>  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND<br> 6675 patty    20   0 1731472 520960  30876 S   8.3  1.6 160:24.79 chrome<br> 6926 patty    20   0  935888 163456  25576 S   4.3  0.5   5:28.13 chrome</pre>
                </div>
        
                <p>Давайте разберём, что означает этот вывод. Вам не нужно запоминать это, но возвращайтесь к этому описанию, когда оно потребуется.</p>
        
                <h4>Первая строка: Общая информация о системе</h4>
                <p>Эта информация аналогична выводу команды <code>uptime</code>. Поля слева направо:</p>
                <ul>
                    <li><strong>Текущее время</strong></li>
                    <li><strong>Время работы системы</strong></li>
                    <li><strong>Количество пользователей в системе</strong></li>
                    <li><strong>Средняя загрузка системы</strong> (load average)</li>
                </ul>
        
                <h4>Вторая строка: Состояние задач (процессов)</h4>
                <p>Задачи, которые выполняются, спят, остановлены и в состоянии зомби</p>
        
                <h4>Третья строка: Информация о CPU</h4>
                <ul>
                    <li><strong>us</strong>: user CPU time - Процент времени CPU, потраченный на выполнение пользовательских процессов без nice</li>
                    <li><strong>sy</strong>: system CPU time - Процент времени CPU, потраченный на выполнение ядра и процессов ядра</li>
                    <li><strong>ni</strong>: nice CPU time - Процент времени CPU, потраченный на выполнение процессов с nice</li>
                    <li><strong>id</strong>: CPU idle time - Процент времени CPU в состоянии простоя</li>
                    <li><strong>wa</strong>: I/O wait - Процент времени CPU, потраченный на ожидание I/O. Если это значение низкое, проблема, вероятно, не в дисковом или сетевом I/O</li>
                    <li><strong>hi</strong>: hardware interrupts - Процент времени CPU, потраченный на обработку аппаратных прерываний</li>
                    <li><strong>si</strong>: software interrupts - Процент времени CPU, потраченный на обработку программных прерываний</li>
                    <li><strong>st</strong>: steal time - Если вы запускаете виртуальные машины, это процент времени CPU, который был "украден" у вас для других задач</li>
                </ul>
        
                <h4>Четвёртая и пятая строки: Использование памяти и swap</h4>
        
                <h4>Список процессов в настоящее время используемых</h4>
                <ul>
                    <li><strong>PID</strong>: Идентификатор процесса</li>
                    <li><strong>USER</strong>: Владелец процесса</li>
                    <li><strong>PR</strong>: Приоритет процесса</li>
                    <li><strong>NI</strong>: Значение nice</li>
                    <li><strong>VIRT</strong>: Виртуальная память, используемая процессом</li>
                    <li><strong>RES</strong>: Физическая память, используемая процессом</li>
                    <li><strong>SHR</strong>: Разделяемая память процесса</li>
                    <li><strong>S</strong>: Статус процесса: S=спящий, R=выполняющийся, Z=зомби, D=непрерываемый, T=остановленный</li>
                    <li><strong>%CPU</strong>: Процент использования CPU этим процессом</li>
                    <li><strong>%MEM</strong>: Процент использования RAM этим процессом</li>
                    <li><strong>TIME+</strong>: Общее время активности этого процесса</li>
                    <li><strong>COMMAND</strong>: Имя процесса</li>
                </ul>
        
                <p>Вы также можете указать идентификатор процесса, если хотите отслеживать только определённые процессы:</p>
        
                <div class="terminal-example">
                    <pre>$ top -p 1</pre>
                </div>
            `
        }
    ];

    const loggingContent = [
        {
            id: 1,
            title: 'Системный журнал',
            content: `
                <h2>Системные логи и служба syslog</h2>
                <p>Службы, ядро, демоны и другие компоненты вашей системы постоянно что-то делают, и эти данные сохраняются на вашей системе в виде логов. Это позволяет нам вести удобный для чтения журнал событий, происходящих в нашей системе. Эти данные обычно хранятся в каталоге <code>/var</code>, который предназначен для изменяемых данных, таких как логи!</p>
    
    
                <p>Как эти сообщения вообще попадают в вашу систему? Для этого существует служба под названием <strong>syslog</strong>, которая отправляет эту информацию системному регистратору.</p>
        
                <p>Syslog фактически состоит из нескольких компонентов, одним из важных является демон <strong>syslogd</strong> (в новых дистрибутивах Linux используется <strong>rsyslogd</strong>), который ожидает появления сообщений о событиях, фильтрует те, которые ему нужно обработать, и в зависимости от того, что должно быть сделано с этим сообщением, отправляет его в файл, на консоль или игнорирует.</p>
        
                <p>Можно было бы подумать, что этот системный регистратор является централизованным местом для управления логами, но, к сожалению, это не так. Вы увидите множество приложений, которые пишут свои собственные правила логирования и генерируют разные файлы логов. Однако в общем случае формат логов должен включать временную метку и детали события.</p>
        
                <p>Вот пример строки из syslog:</p>
        
                <div class="terminal-example">
                    <pre>pete@icebox:~$ less /var/log/syslog<br><br>Jan 27 07:41:32 icebox anacron[4650]: Job 'cron.weekly' started</pre>
                </div>
        
                <p>Здесь мы видим, что 27 января в 07:41:32 наша служба cron запустила задание <code>cron.weekly</code>. Вы можете просмотреть все сообщения о событиях, которые собирает syslog, в файле <code>/var/log/syslog</code>.</p>
            `
        }
    ];

    const networkContent = [
        {
            id: 1,
            title: 'Обзор общего доступа к файлам',
            content: `
                <h2>Сетевой обмен файлами: команда scp</h2>
                <p>Обычно вы не единственный компьютер в сети, особенно если вы работаете в коммерческой среде. Когда нам нужно передать данные с одной машины на другую, иногда может быть проще подключить USB-накопитель и скопировать их вручную. Но в большинстве случаев, если вы работаете с машинами в одной сети, способ передачи данных — это сетевой обмен файлами.</p>
    
                <p>В этом курсе мы рассмотрим несколько различных методов копирования данных на разные машины в вашей сети и обратно. Мы обсудим простое копирование файлов, а затем поговорим о подключении целых каталогов на вашей машине, которые работают как отдельный диск.</p>
        
                <p>Одним из простых инструментов обмена файлами является команда <strong>scp</strong>. Команда <strong>scp</strong> означает secure copy (безопасное копирование) и работает точно так же, как команда <code>cp</code>, но позволяет копировать с одного хоста на другой хост в той же сети. Она работает через SSH, поэтому все ваши действия используют ту же аутентификацию и безопасность, что и SSH.</p>
        
                <p>Чтобы скопировать файл с локального хоста на удалённый хост:</p>
        
                <div class="terminal-example">
                    <pre>$ scp myfile.txt username@remotehost.com:/remote/directory</pre>
                </div>
        
                <p>Чтобы скопировать файл с удалённого хоста на локальный хост:</p>
        
                <div class="terminal-example">
                    <pre>$ scp username@remotehost.com:/remote/directory/myfile.txt /local/directory</pre>
                </div>
        
                <p>Чтобы скопировать каталог с локального хоста на удалённый хост:</p>
        
                <div class="terminal-example">
                    <pre>$ scp -r mydir username@remotehost.com:/remote/directory</pre>
                </div>
            `
        }
    ];

    const networkBasicsContent = [
        {
            id: 1,
            title: 'Основы сети',
            content: `
                <h2>Компоненты домашней сети</h2>
                <p>Давайте рассмотрим типичную домашнюю сеть, которая состоит из нескольких различных компонентов.</p>
    
                <ul>
                    <li><strong>ISP (Internet Service Provider)</strong> - Ваш интернет-провайдер, компания, которой вы платите за доступ к Интернету в вашем доме.</li>
                    <li><strong>Маршрутизатор (Router)</strong> - Маршрутизатор позволяет каждой машине в вашей сети подключаться к Интернету. В большинстве современных маршрутизаторов можно подключиться через беспроводную сеть или Ethernet-кабель.</li>
                    <li><strong>WAN (Wide Area Network)</strong> - Глобальная сеть, так мы называем сеть, которая охватывает всё пространство между вашим маршрутизатором и более крупной сетью, такой как Интернет.</li>
                    <li><strong>WLAN (Wireless Local Area Network)</strong> - Беспроводная локальная сеть, это сеть между вашим маршрутизатором и любыми беспроводными устройствами, которые у вас могут быть, такими как ноутбуки.</li>
                    <li><strong>LAN (Local Area Network)</strong> - Локальная сеть, это сеть между вашим маршрутизатором и любыми проводными устройствами, такими как настольные ПК.</li>
                    <li><strong>Хосты (Hosts)</strong> - Каждая машина в сети известна как хост.</li>
                </ul>
        
                <p>Данные и информация, передаваемые по сетям, известны как пакеты, и к концу раздела "Сетевой кочевник" вы подробно поймёте, как пакет перемещается между хостами.</p>
            `
        }
    ];

    const subnettingContent = [
        {
            id: 1,
            title: 'IPv4',
            content: `
                <h2>IP-адреса и структура сети</h2>
                <p>Итак, мы знаем, что сетевые хосты имеют уникальный адрес, по которому их можно найти. Эти адреса известны как IP-адреса. IPv4-адрес выглядит примерно так:</p>
    
    
                <div class="terminal-example">
                    <pre>204.23.124.23</pre>
                </div>
        
                <p>Этот адрес фактически содержит две части: сетевую часть, которая указывает, в какой сети находится хост, и часть хоста, которая указывает, какой именно это хост в данной сети. В этом курсе мы в основном будем обсуждать IPv4-адреса, которые вы чаще всего встречаетесь, когда речь идет об IP-адресах.</p>
        
                <p>IP-адрес разделен точками на октеты. Таким образом, в IPv4-адресе 4 октета. Если вы немного знакомы с информатикой, октет — это 8 бит, а 8 бит фактически равны 1 байту, поэтому мы также говорим, что IPv4-адрес состоит из 4 байтов. Мы часто используем биты при работе с подсетями и IP-адресами.</p>
        
                <p>Вы можете посмотреть свой IP-адрес с помощью команды <code>ifconfig -a</code>:</p>
        
                <div class="terminal-example">
                    <pre>pete@icebox:~$ ifconfig -a<br><br>eth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce<br>          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0<br>          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link</pre>
                </div>
        
                <p>Как вы можете видеть, мой IPv4-адрес: 192.168.1.129</p>
            `
        }
    ];

    const routingContent = [
        {
            id: 1,
            title: 'Что такое маршрутизатор?',
            content: `
                <h2>Маршрутизаторы и принципы маршрутизации</h2>
                <p>Мы уже использовали термин "маршрутизатор" ранее, и, надеюсь, вы знаете, что это такое, поскольку он, вероятно, есть у вас дома. Маршрутизатор позволяет машинам в сети общаться друг с другом, а также с другими сетями. На типичном маршрутизаторе есть LAN-порты, которые позволяют вашим машинам подключаться к одной локальной сети, а также есть порт для подключения к Интернету, который иногда помечается как WAN, поскольку он essentially подключает вас к более широкой сети. Когда мы выполняем любые сетевые операции, они должны проходить через маршрутизатор. Маршрутизатор решает, куда отправлять наши сетевые пакеты и какие пакеты принимать. Он маршрутизирует наши пакеты между несколькими сетями, чтобы доставить их от исходного хоста к целевому хосту.</p>
    
    
                <h3>Как работает маршрутизатор?</h3>
                <p>Думайте о маршрутизации так же, как о доставке почты. У нас есть адрес, на который мы хотим отправить письмо. Когда мы отправляем его на почту, сотрудники получают письмо и видят: "О, это письмо в Калифорнию, положу его в грузовик, идущий в Калифорнию" (честно говоря, я не знаю, как работает почтовая система). Затем письмо отправляется в Сан-Франциско, внутри Сан-Франциско есть разные почтовые индексы, а в этих индексах — более мелкие адресные коды, пока наконец кто-то не доставит ваше письмо по нужному адресу. С другой стороны, если вы уже живете в Сан-Франциско и в том же почтовом индексе, почтальон, вероятно, будет точно знать, куда должно быть доставлено письмо, не передавая его кому-либо еще.</p>
        
                <p>При маршрутизации пакетов используются аналогичные "маршруты" адресов, например: чтобы попасть в сеть A, отправьте эти пакеты в сеть B. Когда у нас нет установленного маршрута для этого, у нас есть маршрут по умолчанию, который будут использовать наши пакеты. Эти маршруты устанавливаются в таблице маршрутизации, которую наша система использует для навигации по сетям.</p>
        
                <h3>Хопы (Hops)</h3>
                <p>Когда пакеты перемещаются по сетям, они путешествуют "хопами" (переходами). Хоп — это способ приблизительно измерить расстояние, которое пакет должен пройти от источника до назначения. Допустим, у нас есть два маршрутизатора, соединяющих хост A с хостом B, поэтому мы говорим, что между хостом A и хостом B два хопа. Каждый хоп — это промежуточное устройство, такое как маршрутизаторы, через которые мы должны пройти.</p>
        
                <h3>Основные различия между коммутацией, маршрутизацией и flooding</h3>
                <ul>
                    <li><strong>КОММУТАЦИЯ ПАКЕТОВ (Packet SWITCHING)</strong> — это basically получение, обработка и пересылка данных на целевое устройство.</li>
                    <li><strong>МАРШРУТИЗАЦИЯ (ROUTING)</strong> — это процесс создания таблицы маршрутизации, чтобы мы могли лучше выполнять КОММУТАЦИЮ.</li>
                    <li>До появления маршрутизации использовался <strong>FLOODING</strong>. Если маршрутизатор не знает, куда отправить пакет, то каждый входящий пакет отправляется через каждое исходящее соединение, кроме того, через которое он поступил.</li>
                </ul>
            `
        }
    ];

    const networkConfigContent = [
        {
            id: 1,
            title: 'Сетевые интерфейсы',
            content: `
                <h2>Сетевые интерфейсы и их настройка</h2>
                <p>Сетевой интерфейс — это способ, с помощью которого ядро связывает программную сторону сети с аппаратной. Мы уже видели пример этого:</p>
    
                <div class="terminal-example">
                    <pre>pete@icebox:~$ ifconfig -a<br><br>eth0      Link encap:Ethernet  HWaddr 1d:3a:32:24:4d:ce<br>          inet addr:192.168.1.129  Bcast:192.168.1.255  Mask:255.255.255.0<br>          inet6 addr: fd60::21c:29ff:fe63:5cdc/64 Scope:Link</pre>
                </div>
        
                <h3>Команда ifconfig</h3>
                <p>Инструмент <code>ifconfig</code> позволяет нам настраивать наши сетевые интерфейсы. Если у нас не настроены сетевые интерфейсы, драйверы устройств ядра и сеть не будут знать, как общаться друг с другом. Ifconfig запускается при загрузке и настраивает наши интерфейсы через конфигурационные файлы, но мы также можем изменять их вручную. Вывод ifconfig показывает имя интерфейса слева и подробную информацию справа. Чаще всего вы увидите интерфейсы с именами eth0 (первая Ethernet-карта в машине), wlan0 (беспроводной интерфейс), lo (loopback-интерфейс). Loopback-интерфейс используется для представления вашего компьютера — он просто возвращает вас к самому себе. Это полезно для отладки или подключения к серверам, работающим локально.</p>
        
                <p>Состояние интерфейсов может быть up (включено) или down (выключено). Как вы можете догадаться, если вы хотите "выключить" интерфейс, вы можете установить для него состояние down. Поля, которые вы, вероятно, будете чаще всего просматривать в выводе ifconfig, — это HWaddr (MAC-адрес интерфейса), inet addr (IPv4-адрес) и inet6 (IPv6-адрес). Конечно, вы также можете увидеть маску подсети и широковещательный адрес. Вы также можете просмотреть информацию об интерфейсе в <code>/etc/network/interfaces</code>.</p>
        
                <p>Чтобы создать интерфейс и включить его:</p>
        
                <div class="terminal-example">
                    <pre>$ ifconfig eth0 192.168.2.1 netmask 255.255.255.0 up</pre>
                </div>
        
                <p>Это назначает IP-адрес и маску подсети интерфейсу eth0, а также включает его.</p>
        
                <p>Чтобы включить или выключить интерфейс:</p>
        
                <div class="terminal-example">
                    <pre>$ ifup eth0<br>$ ifdown eth0</pre>
                </div>
        
                <h3>Команда ip</h3>
                <p>Команда <code>ip</code> также позволяет нам управлять сетевым стеком системы. В зависимости от используемого дистрибутива это может быть предпочтительным методом изменения сетевых настроек.</p>
        
                <p>Вот некоторые примеры её использования:</p>
        
                <p>Чтобы показать информацию о всех интерфейсах:</p>
        
                <div class="terminal-example">
                    <pre>$ ip link show</pre>
                </div>
        
                <p>Чтобы показать статистику интерфейса:</p>
        
                <div class="terminal-example">
                    <pre>$ ip -s link show eth0</pre>
                </div>
        
                <p>Чтобы показать IP-адреса, выделенные интерфейсам:</p>
        
                <div class="terminal-example">
                    <pre>$ ip address show</pre>
                </div>
        
                <p>Чтобы включать и выключать интерфейсы:</p>
        
                <div class="terminal-example">
                    <pre>$ ip link set eth0 up<br>$ ip link set eth0 down</pre>
                </div>
        
                <p>Чтобы добавить IP-адрес к интерфейсу:</p>
        
                <div class="terminal-example">
                    <pre>$ ip address add 192.168.1.1/24 dev eth0</pre>
                </div>
            `
        }
    ];

    const troubleshootContent = [
        {
            id: 1,
            title: 'ICMP',
            content: `
                <h2>Протокол ICMP (Internet Control Message Protocol)</h2>
                <p>Протокол ICMP (Internet Control Message Protocol) является частью стека протоколов TCP/IP. Он используется для отправки обновлений и сообщений об ошибках и представляет собой чрезвычайно полезный протокол для диагностики сетевых проблем, таких как неудачная доставка пакетов.</p>
    
    
                <p>Каждое ICMP-сообщение содержит поля типа (type), кода (code) и контрольной суммы (checksum). Поле type указывает тип ICMP-сообщения, поле code является подтипом и описывает дополнительную информацию о сообщении, а контрольная сумма используется для обнаружения проблем с целостностью сообщения.</p>
        
                <p>Рассмотрим некоторые распространенные типы ICMP:</p>
        
                <ul>
                    <li><strong>Тип 0</strong> - Echo Reply (Ответ на эхо-запрос)</li>
                    <li><strong>Тип 3</strong> - Destination Unreachable (Адресат недоступен)</li>
                    <li><strong>Тип 8</strong> - Echo Request (Эхо-запрос)</li>
                    <li><strong>Тип 11</strong> - Time Exceeded (Время истекло)</li>
                </ul>
        
                <p>Когда пакет не может достичь назначения, генерируется ICMP-сообщение типа 3. В рамках типа 3 существует 16 значений кода, которые более подробно описывают, почему пакет не может достичь назначения:</p>
        
                <ul>
                    <li><strong>Код 0</strong> - Network Unreachable (Сеть недоступна)</li>
                    <li><strong>Код 1</strong> - Host Unreachable (Узел недоступен)</li>
                    <li>и т.д.</li>
                </ul>
        
                <p>Эти сообщения станут более понятными, когда мы начнем использовать инструменты для диагностики сетевых проблем.</p>
            `
        }
    ];

    const dnsContent = [
        {
            id: 1,
            title: 'Что такое DNS?',
            content: `
                <h2>Система доменных имен (DNS)</h2>
                <p>Представьте, если бы каждый раз, когда вы хотите выполнить поиск в Google, вам приходилось бы вводить http://192.78.12.4 вместо www.google.com. Что ж, без DNS ("Domain Name System" - система доменных имен) именно это и происходило бы. Низкоуровневая сеть понимает только сырой IP-адрес для идентификации хоста. DNS позволяет нам, людям, отслеживать веб-сайты и хосты по имени вместо IP-адреса. Это похоже на список контактов для Интернета. Если вы знаете чье-то имя, но не знаете его номер телефона, вы можете просто найти его в своем списке контактов.</p>
    
    
                <p>DNS по своей сути представляет собой распределенную базу данных, связывающую имена хостов с IP-адресами. Мы управляем нашей базой данных, чтобы люди знали, как попасть на наш сайт/домен, а в другом месте другой человек управляет своей базой данных, чтобы другие могли попасть в их домен. Эти домены затем могут общаться друг с другом и строить огромный список контактов Интернета.</p>
        
                <p>В этом курсе мы рассмотрим некоторые основы DNS, но имейте в виду, что DNS — это обширная тема, и если вы действительно хотите глубоко в ней разобраться, вам нужно будет провести дополнительное исследование.</p>
            `
        }
    ];

    let currentLessons = [];

    function showLesson(id) {
        const lesson = currentLessons.find(lesson => lesson.id === id);
        const contentDiv = document.getElementById('lesson-content');
        if (lesson && contentDiv) {
            contentDiv.innerHTML = lesson.content;
        } else if (contentDiv) {
            contentDiv.innerHTML = '<p>Урок не найден.</p>';
        }
    }

    function loadCategory(category) {
        const lessonList = document.getElementById('lesson-list');
        if (!lessonList) return;

        switch (category) {
            case 'intro':
                currentLessons = introLessons;
                break;
            case 'terminal':
                currentLessons = terminalLessons;
                break;
            case 'textfu':
                currentLessons = textFuContent;
                break;
            case 'advanced-textfu':
                currentLessons = advancedTextFuContent;
                break;
            case 'user-management':
                currentLessons = usersContent;
                break;
            case 'permissions':
                currentLessons = permissionsContent;
                break;
            case 'processes':
                currentLessons = processesContent;
                break;
            case 'packages':
                currentLessons = packagesContent;
                break;
            case 'devices':
                currentLessons = devicesContent;
                break;
            case 'filesystem':
                currentLessons = filesystemContent;
                break;
            case 'boot':
                currentLessons = bootContent;
                break;
            case 'kernel':
                currentLessons = kernelContent;
                break;
            case 'init':
                currentLessons = initContent;
                break;
            case 'process-util':
                currentLessons = processContent;
                break;
            case 'logging':
                currentLessons = loggingContent;
                break;
            case 'network-sharing':
                currentLessons = networkContent;
                break;
            case 'network-basics':
                currentLessons = networkBasicsContent;
                break;
            case 'subnetting':
                currentLessons = subnettingContent;
                break;
            case 'routing':
                currentLessons = routingContent;
                break;
            case 'network-config':
                currentLessons = networkConfigContent;
                break;
            case 'troubleshooting':
                currentLessons = troubleshootContent;
                break;
            case 'dns':
                currentLessons = dnsContent;
                break;
            default:
                currentLessons = introLessons;
        }

        const titleEl = document.getElementById('sidebar-title');
        if (titleEl) {
            titleEl.textContent =
                category === 'intro' ? 'Начало' :
                    category === 'terminal' ? 'Командная строка' :
                        category === 'textfu' ? 'Текст-фу' :
                            category === 'advanced-textfu' ? 'Расширенный текст-фу' :
                                category === 'user-management' ? 'Управление пользователями' :
                                    category === 'permissions' ? 'Разрешения' :
                                        category === 'processes' ? 'Процессы' :
                                            category === 'packages' ? 'Пакеты' :
                                                category === 'devices' ? 'Устройства' :
                                                    category === 'filesystem' ? 'Файловая система' :
                                                        category === 'boot' ? 'Запуск системы' :
                                                            category === 'kernel' ? 'Ядро' :
                                                                category === 'init' ? 'Инициализация' :
                                                                    category === 'process-util' ? 'Использование процесса' :
                                                                        category === 'logging' ? 'Регистрация' :
                                                                            category === 'network-sharing' ? 'Общий доступ к сети' :
                                                                                category === 'network-basics' ? 'Основы сети' :
                                                                                    category === 'subnetting' ? 'Подсети' :
                                                                                        category === 'routing' ? 'Маршрутизация' :
                                                                                            category === 'network-config' ? 'Конфигурация сети' :
                                                                                                category === 'troubleshooting' ? 'Поиск ошибок' :
                                                                                                    category === 'dns' ? 'DNS' :
                                                                                                        'Начало';
        }

        lessonList.innerHTML = '';
        currentLessons.forEach(lesson => {
            const li = document.createElement('li');
            const link = document.createElement('a');
            link.href = '#';
            link.textContent = lesson.title;
            link.addEventListener('click', (e) => {
                e.preventDefault();
                showLesson(lesson.id);
                const sidebar = document.querySelector('.sidebar');
                if (window.innerWidth <= 768 && sidebar) {
                    sidebar.classList.remove('open');
                }
            });
            li.appendChild(link);
            lessonList.appendChild(li);
        });

        if (currentLessons.length > 0) {
            showLesson(currentLessons[0].id);
        }
    }

    const urlParams = new URLSearchParams(window.location.search);
    const category = urlParams.get('category') || 'terminal';
    loadCategory(category);
});